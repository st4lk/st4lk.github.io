<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Python tips &amp; tricks | Developer articles</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Python tips &amp; tricks" />
<meta property="og:locale" content="en" />
<meta name="description" content="Recently i’ve read the book Learning Python, 5th Edition by Mark Lutz. Here is a list of most interesting insights for me." />
<meta property="og:description" content="Recently i’ve read the book Learning Python, 5th Edition by Mark Lutz. Here is a list of most interesting insights for me." />
<link rel="canonical" href="https://st4lk.github.io/en/blog/python/2015/04/30/base-python-tips-tricks.html" />
<meta property="og:url" content="https://st4lk.github.io/en/blog/python/2015/04/30/base-python-tips-tricks.html" />
<meta property="og:site_name" content="Developer articles" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-04-30T18:19:43+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python tips &amp; tricks" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2015-04-30T18:19:43+00:00","datePublished":"2015-04-30T18:19:43+00:00","description":"Recently i’ve read the book Learning Python, 5th Edition by Mark Lutz. Here is a list of most interesting insights for me.","headline":"Python tips &amp; tricks","mainEntityOfPage":{"@type":"WebPage","@id":"https://st4lk.github.io/en/blog/python/2015/04/30/base-python-tips-tricks.html"},"url":"https://st4lk.github.io/en/blog/python/2015/04/30/base-python-tips-tricks.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" type="image/png" href="/favicon.png">
  <link rel="stylesheet" href="/en/assets/main.css">
  <link rel="stylesheet" href="/en/assets/css/styles.css"><link type="application/atom+xml" rel="alternate" href="https://st4lk.github.io/en/feed.xml" title="Developer articles" /><script async defer src="https://buttons.github.io/buttons.js"></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/en/">Developer Articles</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <a class="page-link" href="/en/blog/">Blog</a>
          <a class="page-link" href="/en/about/">About</a>
          <a class="page-link" style="margin-right: 0px" href="/blog/python/2015/04/30/base-python-tips-tricks.html" ><img src="/en/assets/images/ru.png" /></a>
          <a class="page-link" href="/en/blog/python/2015/04/30/base-python-tips-tricks.html" ><img src="/en/assets/images/en.png" /></a>
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Python tips &amp; tricks</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2015-04-30T18:19:43+00:00" itemprop="datePublished">Apr 30, 2015
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="/en/blog/python/2015/04/30/base-python-tips-tricks.html"><img src="https://img-fotki.yandex.ru/get/9067/85893628.c68/0_181e3c_92d918ca_M.jpg" alt="Python tips &amp; tricks" title="Python tips &amp; tricks" /></a></p>

<p>Recently i’ve read the book <a href="http://shop.oreilly.com/product/0636920028154.do">Learning Python, 5th Edition by Mark Lutz</a>.
Here is a list of most interesting insights for me.</p>

<!--more-->

<ul>
  <li>
    <p>set generation:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  {x for x in [1,2]}
  set(x for x in [1,2])
  assert set(x for x in [1,2]) == {x for x in [1,2]}
</code></pre></div>    </div>
  </li>
  <li>
    <p>dict generation:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  {x:x**2 for x in [1,2]}
  dict((x, x**2) for x in [1,2])
  assert {x:x**2 for x in [1,2]} == dict((x, x**2) for x in [1,2])
</code></pre></div>    </div>
  </li>
  <li>
    <p>division of integers</p>

    <p>In python 3 division of integers returns float</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; 1 / 2
  0.5
  &gt;&gt;&gt; - 1 / 2
  -0.5
</code></pre></div>    </div>

    <p>In python 2 division of integers - round to floor, it is not truncate</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; 1 / 2    # 0.5 round floor -&gt; 0
  0
  &gt;&gt;&gt; - 1 / 2  # -0.5 round floor -&gt; -1 (not 0)
  -1
</code></pre></div>    </div>

    <p>In python 2 and 3 round to floor integer division</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; 1 // 2
  0
  &gt;&gt;&gt; - 1 // 2
  -1
  &gt;&gt;&gt; 13 // 2.0
  6.0
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">is</code> - check, that variables point to the same address, <code class="language-plaintext highlighter-rouge">==</code> - check, that variables have same values</p>
  </li>
  <li>
    <p>python 3: <code class="language-plaintext highlighter-rouge">[1, 'spam'].sort()</code> raises exception (different types)</p>
  </li>
  <li>
    <p>python 3: dict().keys() returns iterator (view object, linked to dict). It is set-like object, we can apply set operations to it (union and so on)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; dict(a=1, b=2).keys()
  dict_keys(['b', 'a'])
  &gt;&gt;&gt; dict(a=1, b=2).keys() | {'c', 'd'}
  {'b', 'd', 'a', 'c'}
</code></pre></div>    </div>
  </li>
  <li>
    <p>frozenset - immutable set, hashable, can be used as key in dict</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; fz = frozenset([1,2])
  &gt;&gt;&gt; fz.add(3)
  AttributeError: 'frozenset' object has no attribute 'add'
  &gt;&gt;&gt; {fz: 5}
  {frozenset([1, 2]): 5}
</code></pre></div>    </div>
  </li>
  <li>
    <p>list support compare operators: ==, &lt;, &gt;, &lt;=, &gt;=. List compare is similiar to string compare. In py3 all objects must be the same type</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; [1, 2] == [1, 2]
  True
  &gt;&gt;&gt; [2, 2] &gt; [1, 2]
  True
  &gt;&gt;&gt; [1] &gt; ['sh']  # python2
  False
  &gt;&gt;&gt; [1] &gt; ['sh']  # python3
  TypeError: unorderable types: int() &gt; str()
</code></pre></div>    </div>
  </li>
  <li>
    <p>dict compare</p>

    <p>python 2 and 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; dict(a=1) == dict(a=1)
  True
</code></pre></div>    </div>

    <p>python 2 only</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; dict(a=3) &gt; dict(a=2)
  True
  &gt;&gt;&gt; dict(a=3) &gt; dict(a=2, b=1)
  False
</code></pre></div>    </div>
  </li>
  <li>
    <p>list + string, list + tuple is forbidden, but list += string is allowed</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; L = []
  &gt;&gt;&gt; L + 'spam'
  TypeError: can only concatenate list (not "str") to list

  &gt;&gt;&gt; L = []
  &gt;&gt;&gt; L += 'spam'
  &gt;&gt;&gt; L
  ['s', 'p', 'a', 'm']
</code></pre></div>    </div>
  </li>
  <li>
    <p>L += a is faster than L = L + a.</p>
  </li>
  <li>
    <p>L += [1,2] is in place modification! (new list is not created)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; L = []
  &gt;&gt;&gt; id(L)
  4368997048
  &gt;&gt;&gt; L += [1,2]
  &gt;&gt;&gt; id(L)
  4368997048
  &gt;&gt;&gt; L = L + [1,2]
  &gt;&gt;&gt; id(L)
  4368996976
</code></pre></div>    </div>
  </li>
  <li>
    <p>‘spam’[0][0][0] can last forever, every time we’ll get single-char-string ‘s’</p>
  </li>
  <li>
    <p>variables unpack in python 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; a, *b = 'spam'
  &gt;&gt;&gt; a
  's'
  &gt;&gt;&gt; b
  ['p', 'a', 'm']

  &gt;&gt;&gt; *a, b = 'spam'
  &gt;&gt;&gt; a
  ['s', 'p', 'a']
  &gt;&gt;&gt; b
  'm'

  &gt;&gt;&gt; a, *b, c = 'spam'
  &gt;&gt;&gt; a
  's'
  &gt;&gt;&gt; b
  ['p', 'a']
  &gt;&gt;&gt; c
  'm'
</code></pre></div>    </div>
  </li>
  <li>
    <p>python 2: True = 0, but not in python 3</p>

    <p>python 2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; True = 0
  &gt;&gt;&gt; True
  0
</code></pre></div>    </div>

    <p>python 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; True = 0
  SyntaxError: can't assign to keyword
</code></pre></div>    </div>
  </li>
  <li>
    <p>sys.stdout = open(‘temp.txt’, ‘w’) - all prints goes to file temp.txt</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code> returns object, not True/False</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">while</code> has <code class="language-plaintext highlighter-rouge">else</code></p>
  </li>
  <li>
    <p>python 3: <code class="language-plaintext highlighter-rouge">...</code> is the same as <code class="language-plaintext highlighter-rouge">pass</code></p>
  </li>
  <li>
    <p>reversed works with lists, not generator</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; reversed([1,2,3])
  &lt;list_reverseiterator object at 0x10127c550&gt;
  &gt;&gt;&gt; reversed((x for x in [1,2,3]))
  TypeError: argument to reversed() must be a sequence
</code></pre></div>    </div>
  </li>
  <li>
    <p>zip iterates until the smallest sequence</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; [x for x in zip([1,2,3], [4,5])]
  [(1, 4), (2, 5)]
</code></pre></div>    </div>
  </li>
  <li>
    <p>python 2: map(None, s1, s2) is the same as zip, but iterates until longest sequence. Insert None for elements without pair.</p>

    <p>python 2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; map(None, [1,2,3], [4,5])
  [(1, 4), (2, 5), (3, None)]
  &gt;&gt;&gt; map(None, [1,2], [4,5,6])
  [(1, 4), (2, 5), (None, 6)]
</code></pre></div>    </div>

    <p>python 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; list(map(None, [1,2,3], [4,5]))
  TypeError: 'NoneType' object is not callable
</code></pre></div>    </div>
  </li>
  <li>
    <p>map can take more than one iterators (similiar to zip)</p>

    <p>python 2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; map(lambda x, y: (x, y), [1,2], [3,4])
  [(1, 3), (2, 4)]
  &gt;&gt;&gt; map(lambda x, y: (x, y), [1,2], [3,4,5])
  [(1, 3), (2, 4), (None, 5)]
</code></pre></div>    </div>

    <p>python 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; list(map(lambda x, y: (x, y), [1,2], [3,4]))
  [(1, 3), (2, 4)]
  &gt;&gt;&gt; list(map(lambda x, y: (x, y), [1,2], [3,4,5]))
  [(1, 3), (2, 4)]
</code></pre></div>    </div>
  </li>
  <li>
    <p>nested list comprehensions</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; [x+y for x in 'abc' for y in 'lmn']
  ['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']

  # flat list of lists
  &gt;&gt;&gt; csv = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
  &gt;&gt;&gt; [col for row in csv for col in row]
  [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre></div>    </div>
  </li>
  <li>
    <p>sorted returns list (not generator) in py2 and py3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; sorted(x for x in [2,1,3])
  [1, 2, 3]
</code></pre></div>    </div>
  </li>
  <li>
    <p>*args accept any iterator, not only list</p>
  </li>
  <li>
    <p>unzip: zip(*zip(a,b))</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; zip(*zip([1,2],[3,4]))
  [(1, 2), (3, 4)]
</code></pre></div>    </div>
  </li>
  <li>
    <p>py3: map returns generator, it can be iterated only once</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; m = map(lambda x: x, [1,2,3])
  &gt;&gt;&gt; [x for x in m]
  [1, 2, 3]
  &gt;&gt;&gt; [x for x in m]
  []
</code></pre></div>    </div>
  </li>
  <li>
    <p>py3: range is not a simple generator, it support len() and index access</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; r = range(10)
  &gt;&gt;&gt; r
  range(0, 10)
  &gt;&gt;&gt; len(r)
  10
  &gt;&gt;&gt; r[3]
  3
</code></pre></div>    </div>
  </li>
  <li>
    <p>generator allows only single scan</p>
  </li>
  <li>
    <p>cycle import works! But only for import without from</p>
  </li>
  <li>
    <p>try has else, will be execution when no exception happened</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">with</code> similar to <code class="language-plaintext highlighter-rouge">finally</code></p>
  </li>
  <li>
    <p>except (name1, name2) - orders from top to bottom, from left to right</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">except Exception:</code> vs <code class="language-plaintext highlighter-rouge">except:</code> - first doesn’t catch system errors (KeyboardInterrupt, SystemExit, GeneratorExit например)</p>
  </li>
  <li>
    <p>set().remove(x) - removes x or KeyError, set().discard(x) - removes x or nothing</p>
  </li>
  <li>
    <p>py3.3+ accept u””, U”” for backwards compatibility with py2</p>
  </li>
  <li>
    <p>default encoding is in sys module sys.getdefaultencoding()</p>

    <p>python 2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; sys.getdefaultencoding()
  'ascii'
</code></pre></div>    </div>

    <p>python 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; sys.getdefaultencoding()
  'utf-8'
</code></pre></div>    </div>
  </li>
  <li>
    <p>[c for c in sorted([1,2,3], key=lambda c: -c)] - variable <code class="language-plaintext highlighter-rouge">c</code> will not conflict here</p>
  </li>
  <li>
    <p>in py2 variable inside comprehension can change outer variables and also accessible after, in py3 - not</p>

    <p>python 2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; x = 1
  &gt;&gt;&gt; [x for x in range(3)]
  [0, 1, 2]
  &gt;&gt;&gt; x
  2
  # creates new var
  &gt;&gt;&gt; [y for y in range(3)]
  [0, 1, 2]
  &gt;&gt;&gt; y
  2
</code></pre></div>    </div>

    <p>python 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; x = 1
  &gt;&gt;&gt; [x for x in range(3)]
  &gt;&gt;&gt; x
  1
  # no new var
  &gt;&gt;&gt; [y for y in range(3)]
  [0, 1, 2]
  &gt;&gt;&gt; y
  NameError: name 'y' is not defined
</code></pre></div>    </div>
  </li>
  <li>
    <p>py3 has nonlocal statement. It is used to reference the variable in outer def block (in py2 it is not possible to access such variable)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def f():
      x = 2  # local for f
      def g():
          nonlocal x  # python3 only
          x = 3  # local for g
      g()
      print(x)
  &gt;&gt;&gt; f()  # python3 only
  3
  &gt;&gt;&gt; f()  # with commented nonlocal
  2
</code></pre></div>    </div>
  </li>
  <li>
    <p>LEGB rule (local, enclosing, global, builtin) or LNGB (N=nonlocal) - order of variable search in python</p>
  </li>
  <li>
    <p>py3 exception variable <code class="language-plaintext highlighter-rouge">as name</code> is removed after block execution (even if variable was declared before try block)</p>

    <p>python 2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; x = 1
  &gt;&gt;&gt; try:
  ...     1/0
  ... except Exception as x:
  ...     pass
  &gt;&gt;&gt; x
  ZeroDivisionError('integer division or modulo by zero',)
</code></pre></div>    </div>

    <p>python 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; x = 1
  &gt;&gt;&gt; try:
  ...     1/0
  ... except Exception as x:
  ...     pass
  &gt;&gt;&gt; x
  NameError: name 'x' is not defined
</code></pre></div>    </div>
  </li>
  <li>
    <p>override builtin and undo override</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; open = 99
  &gt;&gt;&gt; open
  99
  &gt;&gt;&gt; del open
  &gt;&gt;&gt; open
  &lt;built-in function open&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>py2 fun: <code class="language-plaintext highlighter-rouge">__builtins__.True = False</code></p>
  </li>
  <li>
    <p>lambda can take default arguments</p>
  </li>
  <li>
    <p>nonlocal functionality can be replaced by mutable object or function attribute</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def f():
      x = [1]
      def g():
          print x[0]
          x.append(2)
      g()
      print x
  &gt;&gt;&gt; f()
  1
  [1, 2]

  def f():
      x = 1
      def g():
          print g.x
          g.x = 2
      g.x = x
      g()
      print g.x
  &gt;&gt;&gt; f()
  1
  2
</code></pre></div>    </div>
  </li>
  <li>
    <p>py3 keyword only arguments</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def f(*args, name):
      print("args", args)
      print("name", name)
  &gt;&gt;&gt; f(1, 2)
  TypeError: f() missing 1 required keyword-only argument: 'name'
  &gt;&gt;&gt; f(1, 2, name=3)
  args (1, 2)
  name 3

  def f(*args, name=3):
      print("args", args)
      print("name", name)
  &gt;&gt;&gt; f(1, 2)
  args (1, 2)
  name 3
</code></pre></div>    </div>
  </li>
  <li>
    <p>in py3 there is unpack of variables, it returns list. And arguments unpack in function call returns tuple</p>

    <p>python 2 and 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def f(a, *b):
      print(b)
  &gt;&gt;&gt; f(1, *[2, 3])
  (2, 3)
</code></pre></div>    </div>

    <p>python 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; a, *b = [1, 2, 3]
  &gt;&gt;&gt; print(b)
  [2, 3]
  &gt;&gt;&gt; a, *b = (1, 2, 3)
  &gt;&gt;&gt; print(b)
  [2, 3]
</code></pre></div>    </div>
  </li>
  <li>
    <p>add list to the beginning of existing list: L[:0] = [1, 2, 3]</p>
  </li>
  <li>
    <p>get and set maximum recursion limit</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; sys.getrecursionlimit()  # 1000
  &gt;&gt;&gt; sys.setrecursionlimit(10000)
  &gt;&gt;&gt; help(sys.setrecursionlimit)
</code></pre></div>    </div>
  </li>
  <li>
    <p>function arguments</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; def f(a):
  ...     b = 1
  ... 
  &gt;&gt;&gt; f.__name__
  'f'
  &gt;&gt;&gt; f.__code__.co_varnames
  ('a', 'b')
  &gt;&gt;&gt; f.__code__.co_argcount
  1
</code></pre></div>    </div>
  </li>
  <li>
    <p>in py3 we can add annotations to function arguments. This information is saved in <code class="language-plaintext highlighter-rouge">func.__annotations__</code>. Nothing is done automatically with annotations, but we can work with them manually (for example for checking type and range of argument from decorator)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; def func(a: 'spam', b: (1, 10), c: float):
  ...     return a + b + c
  &gt;&gt;&gt; func.__annotations__
  {'b': (1, 10), 'c': &lt;class 'float'&gt;, 'a': 'spam'}

  # default values
  &gt;&gt;&gt; def func(a: 'spam'=4, b: (1, 10)=5, c: float=0.1):
  ...     return a + b + c
</code></pre></div>    </div>
  </li>
  <li>
    <p>it is impossible to use <code class="language-plaintext highlighter-rouge">=</code> in lambda, but it is possible to use <code class="language-plaintext highlighter-rouge">setattr</code>, <code class="language-plaintext highlighter-rouge">__dict__</code></p>
  </li>
  <li>
    <p>operator module in std lib</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  import operator as op
  reduce(op.add, [2, 4, 6])
  # same as
  reduce(lambda x, y: x+y, [2, 4, 6])
</code></pre></div>    </div>
  </li>
  <li>
    <p>KISS: Keep It Simple [Sir/Stupid]</p>
  </li>
  <li>
    <p>comprehension vs map in general (better test on your system)</p>

    <p><code class="language-plaintext highlighter-rouge">map(lambda x: x ..)</code> slower than <code class="language-plaintext highlighter-rouge">[x for x ..]</code></p>

    <p><code class="language-plaintext highlighter-rouge">[ord(x) for x ..]</code> slower than <code class="language-plaintext highlighter-rouge">map(ord for x ..)</code></p>

    <p><code class="language-plaintext highlighter-rouge">map(lambda x: L.append(x+10), range(10))</code> even slower than <code class="language-plaintext highlighter-rouge">for x in range(10): L.append(x+10)</code></p>
  </li>
  <li>
    <p>unpacking in lambda differs in py2 and py3</p>

    <p>python 2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; map(lambda (a, b, c): a, [(0,1,2), (3,4,5)])
  [0, 3]
</code></pre></div>    </div>

    <p>python 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; list(map(lambda (a, b, c): a, [(0,1,2), (3,4,5)]))
  SyntaxError: invalid syntax
  &gt;&gt;&gt; list(map(lambda a, b, c: a, [(0,1,2), (3,4,5)]))
  TypeError: &lt;lambda&gt;() missing 2 required positional arguments: 'b' and 'c'
  &gt;&gt;&gt; list(map(lambda row: row[0], [(0,1,2), (3,4,5)]))
  [0, 3]
</code></pre></div>    </div>
  </li>
  <li>
    <p>many builtin functions accept generators, no additional parenthesis are needed</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; "".join(str(x) for x in [1, 2])
  '12'
  &gt;&gt;&gt; sorted(str(x) for x in [1, 2])
  ['1', '2']
</code></pre></div>    </div>

    <p>but for args () is needed</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; sorted(str(x) for x in [1, 2], reverse=True)
  SyntaxError: Generator expression must be parenthesized if not sole argument
  &gt;&gt;&gt; sorted((str(x) for x in [1, 2]), reverse=True)
  ['2', '1']
</code></pre></div>    </div>
  </li>
  <li>
    <p>py3: yield from iterator (following functions are the same)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def f():
      for i in range(5):
          yield i

  def g():
      yield from range(5)
</code></pre></div>    </div>
  </li>
  <li>
    <p>put last list element to the beginning</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  L = L[1:] + L[:1]
</code></pre></div>    </div>
  </li>
  <li>
    <p>zip for single list</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; zip([1,2,3])
  [(1,), (2,), (3,)]
</code></pre></div>    </div>
  </li>
  <li>
    <p>map and zip are similiar</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  map(lambda x,y: (x,y), S1, S2) == zip(S1, S2)
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">python -m script_name</code> - runs module (module is a .py file), that can be found from current search path. Module can be placed somewhere in site-packages folder, but is run as main (<code class="language-plaintext highlighter-rouge">__name__ = '__main__'</code>). If script_name is a package (folder with <code class="language-plaintext highlighter-rouge">__init__.py</code>), then file <code class="language-plaintext highlighter-rouge">__main__.py</code> will be launched. If no such file, then error. Some modules are smart and accepts arguments from command line, for example timeit: <code class="language-plaintext highlighter-rouge">python -m timeit '"-".join(str(n) for n in range(100))'</code></p>
  </li>
  <li>
    <p>there is no direct way to use global and local variable with same name simultaneously. We can play with <code class="language-plaintext highlighter-rouge">__main__.my_global_var</code></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # OK
  X = 99
  def f():
      print(X)
  &gt;&gt;&gt; f()
  99

  # ERROR
  def f():
      print(X)  # &lt;- error
      X = 99
  &gt;&gt;&gt; f()
  UnboundLocalError: local variable 'X' referenced before assignment

  # global everywhere
  def f():
      global X
      print(X)
      X = 88

  # hack with main
  def f():
      import __main__
      print(__main__.X)
      X = 88
</code></pre></div>    </div>
  </li>
  <li>
    <p>square root performance</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  math.sqrt(x)  # fastest
  x ** .5  # fast
  pow(x, .5)  # slow
</code></pre></div>    </div>
  </li>
  <li>
    <p>py3.2+ creates folder <code class="language-plaintext highlighter-rouge">__pycache__</code> for saving bytecode of different python versions there and to reuse them in future. There are no *.pyc files outside this folder now.</p>
  </li>
  <li>
    <p>.pyc for main script (<code class="language-plaintext highlighter-rouge">__name__ = '__main__'</code>) is not created, only for import</p>
  </li>
  <li>
    <p>import search order (look at sys.path):</p>

    <ol>
      <li>home of program (+ in some versions current dir, from where program is launched, i.e. current dir)</li>
      <li>PYTHONPATH</li>
      <li>std lib dir</li>
      <li>content of any .pth file (if exists)</li>
      <li>site-packages dir</li>
    </ol>
  </li>
  <li>
    <p>sys.path can be changed at runtime, this will impact all program</p>
  </li>
  <li>
    <p>python -O creates a little bit optimized bytecode .pyo instead of .pyc, it ~5% faster. Also this flag removes all asserts from code. And changes value of var <code class="language-plaintext highlighter-rouge">__debug__</code></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # main.py
  print __debug__
  assert True == False

  # python main.py
  True
  AssertionError

  # python -O main.py
  False
</code></pre></div>    </div>
  </li>
  <li>
    <p>in py2 in function we can do <code class="language-plaintext highlighter-rouge">from some_module import *</code>, but with warning. In py3 - error</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # python 2
  def f():
      from urllib import *
      print('after import')
  &gt;&gt;&gt; f()
  SyntaxWarning: import * only allowed at module level
  after import

  # python 3
  &gt;&gt;&gt; f()
  SyntaxError: import * only allowed at module level
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">reload</code> doesn’t update objects, that are loaded with from: <code class="language-plaintext highlighter-rouge">from x import y</code>. <code class="language-plaintext highlighter-rouge">y</code> will not be reloaded after <code class="language-plaintext highlighter-rouge">reload(x)</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">reload</code> doesn’t update c modules</p>
  </li>
  <li>
    <p>py3: in package there is <strong>no</strong> package folder in sys.path. If module in package needs to import another module from the same package, relative import must be used: <code class="language-plaintext highlighter-rouge">from . import smth</code>. However, if module is launched as main program (<code class="language-plaintext highlighter-rouge">__main__</code>), then package folder <strong>is</strong> in sys.path.</p>
  </li>
  <li>
    <p>py2: <code class="language-plaintext highlighter-rouge">from __future__ import absolute_import</code> makes import in py2 the same as in py3. It allows to import module string from standard library in following case very easy:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  mypkg
  ├── __init__.py
  ├── main.py  # import string from std here?
  └── string.py
</code></pre></div>    </div>
  </li>
  <li>
    <p>relative import is forbidden outside the package</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # test.py
  from . import a

  # python 2
  python test.py
  ValueError: Attempted relative import in non-package

  # python 3
  python test.py
  SystemError: Parent module '' not loaded, cannot perform relative import
</code></pre></div>    </div>
  </li>
  <li>
    <p>cons of relative import:</p>

    <ul>
      <li>module with relative imports can’t be used as script (<code class="language-plaintext highlighter-rouge">__main__</code>). Solution: use absolute import with package name at the beginning</li>
      <li>derives from previous point: we can’t launch tests, that are executed when running module as main program</li>
    </ul>
  </li>
  <li>
    <p>in py3.3+ there are <em>namespace packages</em>. They don’t have <code class="language-plaintext highlighter-rouge">__init__.py</code>. Two (or more) namespace packages with same name can be placed in different locations in sys.path. Modules from those packages will be aggregated under same package name. If modules have same name - first found in sys.path will be taken. Namespace package always has lower priority under regular package (with <code class="language-plaintext highlighter-rouge">__init__.py</code>). When regular package is found - all found namespace packages with that name are discarded, normal package is used instead. Namespace package import process is slow.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # collect modules in namespace package
  current_dir
  └── mypkg
      └── mymod1.py

  site-packages
  └── mypkg
      └── mymod2.py

  &gt;&gt;&gt; import mypkg.mymod1
  &gt;&gt;&gt; import mypkg.mymod2

  # redefine module in namespace package
  current_dir
  └── mypkg
      └── mymod1.py
      └── mymod2.py

  site-packages
  └── mypkg
      └── mymod2.py

  &gt;&gt;&gt; import mypkg.mymod1
  &gt;&gt;&gt; import mypkg.mymod2  # current_dir.mypkg.mymod2

  # regular package is used
  current_dir
  └── mypkg
      └── mymod1.py

  site-packages
  └── mypkg
      └── mymod2.py

  another-packages
  └── mypkg
      └── mymod1.py

  &gt;&gt;&gt; import sys
  &gt;&gt;&gt; sys.append('another-packages')
  &gt;&gt;&gt; import mypkg.mymod1  # another-packages.mypkg.mymod1
  &gt;&gt;&gt; import mypkg.mymod2
  ImportError: No module named 'mypkg.mymod2'
</code></pre></div>    </div>
  </li>
  <li>
    <p>In py2 and py3 new-style classes (inherent from object), when operator is applied, corresponding magic methods are searched in class, ignoring instance (<code class="language-plaintext highlighter-rouge">__getattr__</code>, <code class="language-plaintext highlighter-rouge">__getattribute__</code> are not invoked). But on direct call of magic method instance is not ignored (<code class="language-plaintext highlighter-rouge">__getattr__</code>, <code class="language-plaintext highlighter-rouge">__getattribute__</code> are invoked).</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class A(object):
      def __repr__(self):
          return "class level repr"
      def normal_method(self):
          return "class level normal method"

  def instance_repr():
      return "instance level repr"
  def instance_normal_method():
      return "instance level normal method"

  a = A()
  print(a)  # class level repr
  print(a.normal_method())  # class level normal method

  a.__repr__ = instance_repr
  a.normal_method = instance_normal_method

  print(a)  # class level repr
  print(a.normal_method())  # instance level normal method

  print(a.__repr__())  # instance level repr
</code></pre></div>    </div>
  </li>
  <li>
    <p>ZODB - object database for python objects, support ACID-compatible transactions (including savepoints)</p>
  </li>
  <li>
    <p>slice object:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  L[2:4] == L[slice(2,4)]
</code></pre></div>    </div>
  </li>
  <li>
    <p>iteration context (for, while, …) will try</p>

    <ol>
      <li><code class="language-plaintext highlighter-rouge">__iter__</code></li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">__getitem__</code></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class Gen(object):
     def __getitem__(self, index):
         if index &gt; 5:
             raise StopIteration()
         return index

 for x in Gen():
     print x,

 # output
 0 1 2 3 4 5
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p>for calls <code class="language-plaintext highlighter-rouge">__iter__()</code>. Then calls method <code class="language-plaintext highlighter-rouge">returned_object.__next__()</code> (in py2 <code class="language-plaintext highlighter-rouge">.next()</code>), until <code class="language-plaintext highlighter-rouge">StopIteration</code>. It is possible to use yield <code class="language-plaintext highlighter-rouge">__item__(): yield smth</code>, then no need to define <code class="language-plaintext highlighter-rouge">__next__</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__call__</code> is invoked, when parentheses <code class="language-plaintext highlighter-rouge">()</code> are applied to instance, not to class</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class A(object):
      def __call__(self):
          print("call")

  a = A()  # nothing
  a()  # print call
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__eq__</code> = True doesn’t mean, that <code class="language-plaintext highlighter-rouge">__ne__</code> = False</p>
  </li>
  <li>
    <p>boolean context:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">__bool__</code> (<code class="language-plaintext highlighter-rouge">__nonzero__</code> in py2)</li>
      <li><code class="language-plaintext highlighter-rouge">__len__</code></li>
      <li>True</li>
    </ul>
  </li>
  <li>
    <p>OOP patterns</p>

    <ul>
      <li>inheritance - “is a”</li>
      <li>composition - “has a” (container stores other objects)</li>
      <li>delegation - special case of composition, when only one object is stored. Wrapper implement same interface, but add some intermediate steps.</li>
    </ul>
  </li>
  <li>
    <p>class attributes (including methods), that start with double underscores <code class="language-plaintext highlighter-rouge">__</code>, but don’t end with them, have special behaviour. They do not overlap with same named attributes in child classes. In <code class="language-plaintext highlighter-rouge">__dict__</code> they are stored as <code class="language-plaintext highlighter-rouge">_ClassName__attrname</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class A(object):
      __x = 1

      def show_a(self):
          print self.__x

  class B(A):

      def show_b(self):
          print self.__x

  &gt;&gt;&gt; a = A()
  &gt;&gt;&gt; a.show_a()
  1
  &gt;&gt;&gt; b = B()
  &gt;&gt;&gt; b.show_a()
  1
  &gt;&gt;&gt; b.show_b()
  AttributeError: 'B' object has no attribute '_B__x'

  class B(A):
      __x = 2

      def show_b(self):
          print self.__x

  &gt;&gt;&gt; b = B()
  &gt;&gt;&gt; b.show_a()
  1
  &gt;&gt;&gt; b.show_b()
  2
</code></pre></div>    </div>
  </li>
  <li>
    <p>in py3 in class method we can suppress self argument and use that method only from class (not from instance) - it will behave as static method. But not in py2.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class A(object):
      def f():
          print("f")

  # python 2
  &gt;&gt;&gt; A.f()
  TypeError: unbound method f() must be called with A instance as first argument (got nothing instead)

  # python 3
  &gt;&gt;&gt; A.f()
  f
  &gt;&gt;&gt; a = A()
  &gt;&gt;&gt; a.f()
  TypeError: f() takes 0 positional arguments but 1 was given
</code></pre></div>    </div>
  </li>
  <li>
    <p>bound function:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class A(object):
      def f(self):
          pass

  a = A()
  print(a.f.__self__)  # that is where self is saved
</code></pre></div>    </div>
  </li>
  <li>
    <p>attribute search in classic (old-style) and new-style classes:</p>

    <ul>
      <li>classic. DFLR: Depth First, Left to Right</li>
      <li>new-style. Diamond pattern, L-R, D-F; MRO (more complex, that just LRDF)</li>
    </ul>

    <p>MRO guards class, from which &gt;= 2 other classes are subclassed, from being search twice. So class will be searched only once.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # python 2 old-style
  class A: attr = 1

  class B(A): pass

  class C(A): attr = 2

  class D(B,C): pass

  &gt;&gt;&gt; x = D()
  &gt;&gt;&gt; print(x.attr)  # x, D, B, A
  1

  # python 2 new-style
  class A(object): attr = 1

  class B(A): pass

  class C(A): attr = 2

  class D(B,C): pass

  &gt;&gt;&gt; x = D()
  &gt;&gt;&gt; print(x.attr)  # x, D, B, C
  2

  # scheme
  A     A
  |     |
  B     C
  \     /
     |
     D
     |
     X
</code></pre></div>    </div>

    <p>Check search order in new-style (mro algorithm):</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; D.__mro__
  (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;)
  &gt;&gt;&gt; D.mro()  # same as list(D.__mro__)
  [&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;]
</code></pre></div>    </div>
  </li>
  <li>
    <p>format() calls method <code class="language-plaintext highlighter-rouge">__format__</code>. If it is not exist, then TypeError in py2.</p>

    <p>python 2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; print('{0}'.format(object))
  &lt;type 'object'&gt;
  &gt;&gt;&gt; print('{0}'.format(object.__reduce__))
  TypeError: Type method_descriptor doesn't define __format__
  # call __str__ explictly
  &gt;&gt;&gt; print('{0!s}'.format(object.__reduce__))
  &lt;method '__reduce__' of 'object' objects&gt;
</code></pre></div>    </div>

    <p>python 3.4</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; print('{0}'.format(object.__reduce__))
  &lt;method '__reduce__' of 'object' objects&gt;
</code></pre></div>    </div>

    <p>python 2 &amp; 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class A(object):
      def __format__(self, *args):
          return "A.__format__"

      def __str__(self):
          return "A.__str__"

  &gt;&gt;&gt; a = A()
  &gt;&gt;&gt; "{0}".format(a)
  'A.__format__'
  &gt;&gt;&gt; print(a)
  A.__str__
  &gt;&gt;&gt; '%s' % a
  'A.__str__'
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__dict__</code> doesn’t contain “virtual” attributes:</p>

    <ul>
      <li>new-style properties (<code class="language-plaintext highlighter-rouge">@property</code>)</li>
      <li>slots</li>
      <li>descriptors</li>
      <li>dynamic attrs computed with tools like <code class="language-plaintext highlighter-rouge">__getattr__</code></li>
    </ul>
  </li>
  <li>
    <p>MRO - method resolution order</p>
  </li>
  <li>
    <p>diamond pattern - special case of ‘multi inheritance’, when 2 or more class can be child of the same class (object). This pattern is used in python.</p>
  </li>
  <li>
    <p>proxy object, returned by <code class="language-plaintext highlighter-rouge">super()</code>, doesn’t work with operators:</p>

    <p>python 3</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class A(list):
      def get_some(self):
          return super()[0]

  &gt;&gt;&gt; a = A([1, 2])
  &gt;&gt;&gt; a.get_some()
  TypeError: 'super' object is not subscriptable

  class A(list):
      def get_some(self):
          return super().__getitem__(0)

  &gt;&gt;&gt; a = A([1,2])
  &gt;&gt;&gt; a.get_some()
  1
</code></pre></div>    </div>

    <p>python 2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class A(list):
      def get_some(self):
          return super(A, self)[0]

  &gt;&gt;&gt; a = A([1,2])
  &gt;&gt;&gt; a.get_some()
  TypeError: 'super' object has no attribute '__getitem__'

  class A(list):
      def get_some(self):
          return super(A, self).__getitem__(0)

  &gt;&gt;&gt; a = A([1,2])
  &gt;&gt;&gt; a.get_some()
  1
</code></pre></div>    </div>
  </li>
  <li>
    <p>super()</p>

    <ul>
      <li>
        <p>super() pros:</p>

        <ul>
          <li>if superclass need to be changed in runtime, we can’t do it without super: <code class="language-plaintext highlighter-rouge">C.__bases__ = (Y, )</code></li>
          <li>
            <p>calls sequence of inherited methods in multi inheritance class, in MRO order.</p>

            <p>If we’ll try to do it without super, we can call method of some class twice.</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class A(object):
      def __init__(self):
          print("A")

  class B(A):
      def __init__(self):
          print("B")
          super(B, self).__init__()

  class C(A):
      def __init__(self):
          print("C")
          super(C, self).__init__()

  class D(B, C):
      pass

  &gt;&gt;&gt; d = D()
  B
  C
  A  # A only once
  &gt;&gt;&gt; B.mro()
  [&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;]
  &gt;&gt;&gt; D.mro()
  [&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;]
</code></pre></div>            </div>

            <p>Sequence of methods</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class B(object):
      def __init__(self):
          print("B")
          # for B super is C here, by MRO order
          super(B, self).__init__()

  class C(object):
      def __init__(self):
          print("C")
          # it is ok here to call super().__init__
          # because object also has __init__
          super(C, self).__init__()

  class D(B, C):
      pass

  &gt;&gt;&gt; d = D()
  B
  C
</code></pre></div>            </div>
          </li>
          <li>super will search attribute in MRO hierarchy. It will search all classes. So, for example hierarchy for super is the following: <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">C</code>. <code class="language-plaintext highlighter-rouge">A</code> doesn’t have attribute, whereas <code class="language-plaintext highlighter-rouge">C</code> has, then C.method will be used without error.</li>
        </ul>
      </li>
      <li>
        <p>super() cons (or features):</p>

        <ul>
          <li>when super is used, all methods in sequence must accept same arguments</li>
          <li>super().m - all classes must have method m and call super().m, except last one, that must not call super.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>inherit method from exact class:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class A(B, C):
      other = C.other  # not B other
</code></pre></div>    </div>
  </li>
  <li>
    <p>finally block will be called even if exception was happened in except or else block</p>
  </li>
  <li>
    <p>exception - always instance, even if raise ExceptionClass (without <code class="language-plaintext highlighter-rouge">()</code>). Instance will be created automatically (without arguments):</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  raise Exception  # == raise Exception()
  raise  # reraise caught exception
</code></pre></div>    </div>
  </li>
  <li>
    <p>py2, look for builtin exceptions:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  import exceptions
  help(exceptions)
</code></pre></div>    </div>
  </li>
  <li>
    <p>the downside of reading bytes from file and further manual decoding: if we’ll read by chunks, then some nasty case can happen, when one byte of one symbol will fall in first chunk, and another byte of same symbol - in second chunk. So it is better to use codecs.open in py2.</p>
  </li>
  <li>
    <p>When file name is given in unicode, python will automatically decode and encode from/to bytes. When file name is in bytes, then no encoding is happen. Default encoding for file names:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; sys.getfilesystemencoding()
  'utf-8'
</code></pre></div>    </div>
  </li>
  <li>
    <p>descriptor - class, that implement one of the following methods</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">__get__</code></li>
      <li><code class="language-plaintext highlighter-rouge">__set__</code></li>
      <li><code class="language-plaintext highlighter-rouge">__delete__</code></li>
    </ul>
  </li>
  <li>
    <p>If descriptor doesn’t implement <code class="language-plaintext highlighter-rouge">__set__</code>, it doesn’t mean, that corresponding attribute is read-only. Attribute will be simply rewritten. To avoid it, implement <code class="language-plaintext highlighter-rouge">__set__</code> with exception.</p>
  </li>
  <li>
    <p>decorators can be combined, they will be called from bottom to top:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  @A
  @B
  @C
  def f(): pass

  # same as

  f = A(B(C(f)))
</code></pre></div>    </div>
  </li>
  <li>
    <p>decorator can accept arguments</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  @dec(a, b)
  def f(): pass

  # same as

  f = dec(a, b)(f)

  # implementation:

  def dec(a, b):
      def actual_dec(f):
          return f
      return actual_dec
</code></pre></div>    </div>

    <p>So decorator can include <strong>3 levels of callables</strong>:</p>

    <ul>
      <li>callable to accept decorator args</li>
      <li>callable to serve as decorator</li>
      <li>callable to handle calls to the original function</li>
    </ul>
  </li>
  <li>
    <p>during class creation, two methods of class type are called:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  type.__new__(type_class, class_name, super_classes, attr_dict)
  type.__init__(class, class_name, super_classes, attr_dict)

  # python 3
  class Eggs: pass

  class Spam(Eggs):
      data = 1
      def method(self, arg): pass

  # same as
  Eggs = type('Eggs', (), ...)  # in () object will be added automatically in python 3

  Spam = type('Spam', (Eggs, ), {'data': 1, 'method': method, '__module__': '__main__'})
</code></pre></div>    </div>
  </li>
  <li>
    <p>Set metaclass</p>

    <p><strong>python 2</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class Spam(object):
      __metaclass__ = Meta
</code></pre></div>    </div>

    <p>Inherit from object is not mandatory, but if it is not present, and <code class="language-plaintext highlighter-rouge">__metaclass__</code>
  is used, then result will be new-style anyway, and in <code class="language-plaintext highlighter-rouge">__bases__</code> object will be present.
  But better to use object explicitly, as there can be problems, for example with inheritance.</p>

    <p><strong>python 3</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class Spam(Eggs, metaclass=Meta):
      pass
</code></pre></div>    </div>

    <p>attribute <code class="language-plaintext highlighter-rouge">__metaclass__</code> is just ignored</p>
  </li>
  <li>
    <p>Metaclass can not be a class itself. It just must return class. Function also can be a metaclass:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def meta_func(class_name, bases, attr_dict):
      return type(class_name, bases, attr_dict)

  # python 2
  class Spam(object):
      __metaclass__ = meta_func
</code></pre></div>    </div>
  </li>
  <li>
    <p>Regular classes also have method <code class="language-plaintext highlighter-rouge">__new__</code>. But it doesn’t create class, it is invoked at instance creation (takes class as input argument). This method calls <code class="language-plaintext highlighter-rouge">__init__</code>.</p>
  </li>
  <li>
    <p>Magic methods of metaclass and class:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class Meta(type): pass
</code></pre></div>    </div>

    <p>on creation of class Class (<code class="language-plaintext highlighter-rouge">class Class(metaclass=Meta): ...</code>) following methods are called:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Meta.__new__
  Meta.__init__
</code></pre></div>    </div>

    <p>on creation of instance of class Class (<code class="language-plaintext highlighter-rouge">instance = Class(...)</code>) following methods are called:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Meta.__call__
      calls Class.__new__
          calls Class.__init__
</code></pre></div>    </div>

    <p>on calling of instance of class Class (<code class="language-plaintext highlighter-rouge">instance()</code>) following method is called:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Class.__call__
</code></pre></div>    </div>
  </li>
  <li>
    <p>It is not mandatory to subclass metaclass from type. We can use simple class with <code class="language-plaintext highlighter-rouge">__new__</code> method as metaclass. But in that case methods <code class="language-plaintext highlighter-rouge">__init__</code> and <code class="language-plaintext highlighter-rouge">__call__</code> will not be called:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class MySimpleMetaClass(object):
      def __new__(cls, *args, **kwargs):
          new_class = type.__new__(type, *args, **kwargs)
          return new_class

      def __init__(new_class, *args, **kwargs):
          print("__init__ won't be called...")

      def __call__(*args, **kwargs):
          print("__call__ won't be called...")
</code></pre></div>    </div>
  </li>
  <li>
    <p>Metaclass of some class will be invoked for all subclasses. When <code class="language-plaintext highlighter-rouge">__new__</code> of metaclass is called for parent class, bases will contain <code class="language-plaintext highlighter-rouge">(&lt;type 'object'&gt;,)</code>, and for subclass - parent class.</p>
  </li>
  <li>
    <p>Metaclass attributes are inherited by class, not by instances of class.</p>

    <p>python 2 (python 3 has some syntax differences)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class MyMetaClass(type):
      attr = 2

      def __new__(*args, **kwargs):
          return type.__new__(*args, **kwargs)

      def toast(*args, **kwargs):
          print(args, kwargs)

  class A(object):
      __metaclass__ = MyMetaClass
</code></pre></div>    </div>

    <p>Metaclass is included in search sequence of class attributes</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; A.toast()
  ((&lt;class '__main__.A'&gt;,), {})
</code></pre></div>    </div>

    <p>Interesting, that method from metaclass is bound, although is called from class, not from instance. In fact class - is an instance of metaclass:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; A.toast
  &lt;bound method MyMetaClass.toast of &lt;class '__main__.A'&gt;&gt;
</code></pre></div>    </div>

    <p>But metaclass is not present in instance attribute search sequence</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; a = A()
  &gt;&gt;&gt; a.toast()
  AttributeError: 'A' object has no attribute 'toast'
</code></pre></div>    </div>

    <p>If some superclass has attribute with same name, as in metaclass, it has higher priority (no matter how deep superclass is)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class B(object):
      attr = 1

  class C(B):
      __metaclass__ = MyMetaClass

  &gt;&gt;&gt; C.attr
  1  # MyMetaClass.attr = 2 is ignored
</code></pre></div>    </div>

    <p>Instance attributes are searched in its <code class="language-plaintext highlighter-rouge">__dict__</code>, next in all <code class="language-plaintext highlighter-rouge">__dict__</code> of <code class="language-plaintext highlighter-rouge">__class__.__mro__</code>
  Class attributes are searched also in <code class="language-plaintext highlighter-rouge">__class__.__mro__</code>, it is different class, from instance it will be <code class="language-plaintext highlighter-rouge">__class__.__class__.__mro__</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; inst = C()
  &gt;&gt;&gt; inst.__class__ -&gt; &lt;class '__main__.C'&gt;
  &gt;&gt;&gt; C.__bases__    -&gt; (&lt;class '__main__.B'&gt;,)
  &gt;&gt;&gt; C.__class__    -&gt; &lt;class '__main__.MyMetaClass'&gt;
</code></pre></div>    </div>

    <p>Instance inherit attributes from all superclasses. Class - from superclasses and metaclasses. Metaclasses - from super-metaclasses (and probably from meta-metaclasess).</p>

    <p>Data descriptors (those, that define <code class="language-plaintext highlighter-rouge">__set__</code>) brings some changes in attribute search order for instances.
  For class instance, data descriptor will have higher priority in search, even if they are declared in superclasess:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class DataDescriptor(object):
      def __get__(self, instance, owner):
          print("DataDescriptor.__get__")
          return 5
      def __set__(self, instance, value):
          print("DataDescriptor.__set__", value)


  class B(object):
      attr = DataDescriptor()

  class C(B):
      pass

  &gt;&gt;&gt; c = C()
  &gt;&gt;&gt; c.__dict__['attr'] = 88
  &gt;&gt;&gt; c.attr
  DataDescriptor.__get__
  5
  &gt;&gt;&gt; c.attr = 8
  ('DataDescriptor.__set__', 8)
</code></pre></div>    </div>

    <p>Descriptor was called, in spite of attribute with same name is present in <code class="language-plaintext highlighter-rouge">c.__dict__</code>.
  Attribute doesn’t hide descriptor of superclass.
  Such behaviour will not happen in case of nondata descriptor:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class SimpleDescriptor(object):
      def __get__(self, instance, owner):
          print("SimpleDescriptor.__get__")
          return 5

  class B(object):
      attr = SimpleDescriptor()

  class C(B):
      pass

  &gt;&gt;&gt; c = C()
  &gt;&gt;&gt; c.attr
  SimpleDescriptor.__get__
  5
  &gt;&gt;&gt; c.__dict__['attr'] = 88
  &gt;&gt;&gt; c.attr
  88
</code></pre></div>    </div>

    <p>Also, for builtin operators that call magic methods implicitly, the search order is special. It ignores <code class="language-plaintext highlighter-rouge">instance.__dict__</code>, the search goes to <code class="language-plaintext highlighter-rouge">__dict__</code> of classes from <code class="language-plaintext highlighter-rouge">__mro__</code>.</p>
  </li>
  <li>
    <p>magic methods, that are called implicitly by builtin operators, are searched in metaclasses, ignoring the class (and all its superclasses)</p>

    <p>python 2 (in python 3 syntax differs a little bit)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class MyMetaClass(type):
      def __new__(*args, **kwargs):
          return type.__new__(*args, **kwargs)
      def __str__(cls):
          return "__str__ from meta"

  class A(object):
      __metaclass__ = MyMetaClass
      def __str__(self):
          return "__str__ from class A"
</code></pre></div>    </div>

    <p>Method <code class="language-plaintext highlighter-rouge">MyMetaClass.__str__</code> will be called, not <code class="language-plaintext highlighter-rouge">A.__str__</code></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; print A
  __str__ from meta
</code></pre></div>    </div>

    <p>And here method <code class="language-plaintext highlighter-rouge">object.__str__</code> will be called:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &gt;&gt;&gt; print MyMetaClass
  &lt;class '__main__.MyMetaClass'&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>Author Mark Lutz is a little upset, that python become too complicated nowadays. It have more than one obvious way to do some things:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">str.format</code> and <code class="language-plaintext highlighter-rouge">%</code></li>
      <li><code class="language-plaintext highlighter-rouge">with</code> and <code class="language-plaintext highlighter-rouge">try/finally</code></li>
    </ul>

    <p>It goes contrary with <code class="language-plaintext highlighter-rouge">import this</code> Zen.</p>
  </li>
</ul>

  </div><a class="u-url" href="/en/blog/python/2015/04/30/base-python-tips-tricks.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/en/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Developer articles</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Developer articles</li><li><a class="u-email" href="mailto:alexevseev@gmail.com">alexevseev@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/st4lk"><svg class="svg-icon"><use xlink:href="/en/assets/minima-social-icons.svg#github"></use></svg> <span class="username">st4lk</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
