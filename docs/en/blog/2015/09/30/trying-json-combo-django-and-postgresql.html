<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Trying JSON in Django and PostgreSQL (and compare with MongoDB) | Alexey Evseev</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Trying JSON in Django and PostgreSQL (and compare with MongoDB)" />
<meta name="author" content="Alexey Evseev" />
<meta property="og:locale" content="en" />
<meta name="description" content="New JSONField will be added in Django 1.9, it can be used with PostgreSQL &gt;= 9.4. Let’s try to work with it and find out, in what situations it can be useful." />
<meta property="og:description" content="New JSONField will be added in Django 1.9, it can be used with PostgreSQL &gt;= 9.4. Let’s try to work with it and find out, in what situations it can be useful." />
<link rel="canonical" href="https://st4lk.github.io/en/blog/2015/09/30/trying-json-combo-django-and-postgresql.html" />
<meta property="og:url" content="https://st4lk.github.io/en/blog/2015/09/30/trying-json-combo-django-and-postgresql.html" />
<meta property="og:site_name" content="Alexey Evseev" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-09-30T18:19:43+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Trying JSON in Django and PostgreSQL (and compare with MongoDB)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Alexey Evseev"},"dateModified":"2015-09-30T18:19:43+00:00","datePublished":"2015-09-30T18:19:43+00:00","description":"New JSONField will be added in Django 1.9, it can be used with PostgreSQL &gt;= 9.4. Let’s try to work with it and find out, in what situations it can be useful.","headline":"Trying JSON in Django and PostgreSQL (and compare with MongoDB)","mainEntityOfPage":{"@type":"WebPage","@id":"https://st4lk.github.io/en/blog/2015/09/30/trying-json-combo-django-and-postgresql.html"},"url":"https://st4lk.github.io/en/blog/2015/09/30/trying-json-combo-django-and-postgresql.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" type="image/png" href="/favicon.png">
  <link rel="stylesheet" href="/en/assets/main.css">
  <link rel="stylesheet" href="/en/assets/css/styles.css"><link type="application/atom+xml" rel="alternate" href="https://st4lk.github.io/en/feed.xml" title="Alexey Evseev" /><link type="application/atom+xml" rel="alternate" href="https://st4lk.github.io/en/feed.xml" title="Alexey Evseev" /><script async defer src="https://buttons.github.io/buttons.js"></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/en/">Alexey Evseev</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <a class="page-link" href="/en/blog/">Blog</a>
          <a class="page-link" href="/en/contact/">Contact</a>
          <a class="page-link" style="margin-right: 0px" href="/blog/2015/09/30/trying-json-combo-django-and-postgresql.html" ><img src="/en/assets/images/ru.png" /></a>
          <a class="page-link" href="/en/blog/2015/09/30/trying-json-combo-django-and-postgresql.html" ><img src="/en/assets/images/en.png" /></a>
          <a class="page-link" href="/en/search/" ><img src="/en/assets/images/search.svg" /></a>
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Trying JSON in Django and PostgreSQL (and compare with MongoDB)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2015-09-30T18:19:43+00:00" itemprop="datePublished">Sep 30, 2015
      </time><span style="float:right">

  <span><a href="/en/category/database/index.html">database</a></span>
&nbsp;

  <span><a href="/en/category/django/index.html">django</a></span>
&nbsp;

  <span><a href="/en/category/mongodb/index.html">mongodb</a></span>
&nbsp;

  <span><a href="/en/category/postgresql/index.html">postgresql</a></span>
&nbsp;

  <span><a href="/en/category/sql/index.html">sql</a></span>


</span>
    </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="/en/blog/2015/09/30/trying-json-combo-django-and-postgresql.html"><img src="https://img-fotki.yandex.ru/get/3706/85893628.c69/0_19430e_cafd0257_XL.png" alt="Trying JSON in Django and PostgreSQL" title="Trying JSON in Django and PostgreSQL" /></a></p>

<p>New <a href="https://docs.djangoproject.com/en/1.9/ref/contrib/postgres/fields/#jsonfield">JSONField</a> will be added in Django 1.9, it can be used with PostgreSQL &gt;= 9.4. Let’s try to work with it and find out, in what situations it can be useful.</p>

<!--more-->

<p>Currently django 1.9 alpha is available, final version is scheduled on December 2015.
Alpha can be installed with pip:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install --pre django
</code></pre></div></div>

<p>Now imagine that we have an e-commerce site, where we offer products of different types. For example, laptops and t-shirts. Obviously, such goods will have different attributes: t-shirts will have size, color and laptops - screen size, CPU frequency, hard drive and so on. One of the approaches to design such data in SQL is <a href="https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model">Entity–attribute–value model (EAV)</a>.</p>

<p>But now we have JSON, so let’s try to organise data using this type.</p>

<p>Create simple model for products:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.db import models
from django.contrib.postgres.fields import JSONField

class Category(models.Model):
    name = models.CharField(max_length=100)

class Product(models.Model):
    name = models.CharField(max_length=100)
    category = models.ForeignKey(Category)
    price = models.IntegerField()
    attributes = JSONField()

    def __str__(self):
        return self.name
</code></pre></div></div>

<p>As we can see, there are several common fields for all products (name, category, price) plus specific to particular product attributes (as JSON field).</p>

<p>Create objects:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tshirt = Category.objects.create(name='tshirts')
notebook = Category.objects.create(name='notebook')

# Tshirts
Product.objects.create(name='Silk tshirt', category=tshirt, price=100, attributes={
    'colors': ['red', 'black'],
    'sizes': ['S', 'M'],
    'model': 'polo',
    'material': 'silk',
})

Product.objects.create(name='Bamboo tshirt', category=tshirt, price=120, attributes={
    'colors': ['white', 'yellow'],
    'sizes': ['M', 'L', 'XL'],
    'model': 'poet',
    'material': 'bamboo',
})

# Notebooks
Product.objects.create(name='MacBook Pro', category=notebook, price=2000, attributes={
    'brand': 'Apple',
    'screen': 15.0,
    'speed': 2200,
    'hd': 256,
})

Product.objects.create(name='ATIV Book 9', category=notebook, price=1200, attributes={
    'brand': 'Samsung',
    'screen': 12.2,
    'speed': 2400,
    'hd': 128,
})
</code></pre></div></div>

<h3 id="queries">Queries</h3>

<p>Let’s see, what queries we can make.</p>

<ol>
  <li>
    <p>Get t-shirts with both ‘M’ and ‘L’ sizes:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=tshirt, attributes__contains={'sizes': ['M', 'L']})
 [&lt;Product: Bamboo tshirt&gt;]
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get t-shirts with both ‘M’ and ‘L’ sizes, both white and yellow colors, with poetry on it (model=poet):</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=tshirt,
     attributes__contains={'sizes': ['M', 'L'], 'colors': ['white', 'yellow'],
     'model': 'poet'})
 [&lt;Product: Bamboo tshirt&gt;]
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get laptops with CPU frequency 2400 and screen size 12.2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=notebook,
     attributes__contains={'speed': 2400, 'screen': 12.2})
 [&lt;Product: ATIV Book 9&gt;]
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get t-shirts with red color, model polo and with size ‘M’ or ‘L’</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=tshirt,
     attributes__contains={'colors': ['red'], 'model': 'polo'},
     attributes__sizes__has_any_keys=['M', 'L'])
 [&lt;Product: Silk tshirt&gt;]
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get laptops with CPU greater that 2000 and screen larger that 13</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=notebook, attributes__speed__gt=2000,
     attributes__screen__gt=13)
 [&lt;Product: MacBook Pro&gt;]
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get laptops with CPU frequency equal to 2200 or 2400</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=notebook, attributes__speed__in=(2200, 2400))
 [&lt;Product: ATIV Book 9&gt;, &lt;Product: MacBook Pro&gt;]
</code></pre></div>    </div>

    <p>or like this:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; from django.db.models import Q
 &gt;&gt;&gt; Product.objects.filter(category=notebook).filter(
     Q(attributes__contains={'speed': 2200}) | Q(attributes__contains={'speed': 2400}))
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="indexes">Indexes</h3>

<p>Let’s find out, how effective can be our queries.</p>

<p>PostgreSQL supports <a href="http://www.postgresql.org/docs/9.4/static/datatype-json.html#JSON-INDEXING">different indexes</a> for JSON types:</p>

<ul>
  <li>
    <p>GIN</p>

    <p>this index in its turn can support different operators:</p>

    <ul>
      <li>jsonb_ops (default), supports operators <code class="language-plaintext highlighter-rouge">@&gt;, ?, ?&amp;, ?|</code></li>
      <li>jsonb_path_ops, supports only <code class="language-plaintext highlighter-rouge">@&gt;</code>, but works faster and requires less space</li>
    </ul>
  </li>
  <li>
    <p>btree</p>

    <p>can be useful in searching exact json document</p>
  </li>
  <li>
    <p>hash</p>

    <p>same as btree, can be useful in searching exact json document</p>
  </li>
</ul>

<h4 id="сorrespondence-of-some-django-operations-and-postgresql-operators">Сorrespondence of some Django operations and PostgreSQL operators</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Django        Postgres
----------------------
contains      @&gt;
contained_by  &lt;@
has_key       ?
has_any_keys  ?|
has_keys      ?&amp;
</code></pre></div></div>

<p>In our case the most interesting operator is <code class="language-plaintext highlighter-rouge">@&gt;</code>. Django will transform operation <code class="language-plaintext highlighter-rouge">contains</code> to it for json fields.</p>

<p>If we simply add <code class="language-plaintext highlighter-rouge">db_index=True</code>, btree index will be created:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Product(models.Model):
    ...
    attributes = JSONField(db_index=True)
</code></pre></div></div>

<p>For our queries GIN index will be more applicable. To create it we’ll use <a href="https://docs.djangoproject.com/en/dev/ref/migration-operations/#django.db.migrations.operations.RunSQL">RunSQL</a> operation.</p>

<p>First create empty migration. In current example app with products has name ‘catalogue_simple’</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python manage.py makemigrations --empty catalogue_simple
</code></pre></div></div>

<p>In created file (in my case it is 0002_auto_20150928_1610.py) add couple imports and commands to create and discard index:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from catalogue_simple.models import Product
from psycopg2.extensions import AsIs

class Migration(migrations.Migration):
    # ...
    operations = [
        migrations.RunSQL(
            [("CREATE INDEX catalogue_product_attrs_gin ON %s USING gin"
                "(attributes jsonb_path_ops);", [AsIs(Product._meta.db_table)])],
            [('DROP INDEX catalogue_product_attrs_gin;', None)],
        )
    ]
</code></pre></div></div>

<p>Here catalogue_product_attrs_gin - index name (we can choose any), attributes - name of JSON field, Product - product model. We are creating jsonb_path_ops index, as it will cover the most common operation in our queries - <code class="language-plaintext highlighter-rouge">contains</code>. Extension <code class="language-plaintext highlighter-rouge">AsIs</code> is used to not wrap <code class="language-plaintext highlighter-rouge">%s</code> param with single quotes.</p>

<p>We don’t need btree index, so don’t add it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Product(models.Model):
    ...
    attributes = JSONField()
</code></pre></div></div>

<h4 id="test-data">Test data</h4>

<p>I’ve generated 1 000 000 products of 4 different categoires, 250 000 in each. Every product category has its own attributes, from 4 to 7 keys. Some values are scalar (t-shirt material), some - lists (t-shirt sizes).</p>

<h4 id="queries-and-indexes">Queries and indexes</h4>

<ol>
  <li>
    <p>Get t-shirts with both ‘M’ and ‘L’ sizes:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=tshirt, attributes__contains={'sizes': ['M', 'L']})
</code></pre></div>    </div>

    <p>Corresponding SQL (enumeration of all field names is replaced with <code class="language-plaintext highlighter-rouge">*</code> for brevity):</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> SELECT * FROM "catalogue_simple_product" WHERE
 ("catalogue_simple_product"."category_id" = 5
     AND
 "catalogue_simple_product"."attributes" @&gt; '{"sizes": ["M", "L"]}');
</code></pre></div>    </div>

    <p>Without GIN index on attributes query time is 292 ms, <a href="http://explain.depesz.com/s/xmWS">EXPLAIN ANALYSE</a>.</p>

    <p>Same query with GIN index - 250 ms, <a href="http://explain.depesz.com/s/cHk">EXPLAIN ANALYSE</a>.</p>

    <p>In this case we don’t gain much performance (292 ms vs 250 ms), because result contains a lot of rows: 66412.
 It is called “low selectivity”.
 Selectivity - ratio of filtered rows to the total rows. If this ratio tends to 1, we say “low selectivity”, to 0 - “high selectivity”.
 This metric helps us to estimate index effectiveness. With low selectivity index will not gain much performance.</p>
  </li>
  <li>
    <p>Get t-shirts with both ‘M’ and ‘L’ sizes, both white and yellow colors, with poetry on it (model=poet):</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=tshirt,
     attributes__contains={'sizes': ['M', 'L'], 'colors': ['white', 'yellow'],
     'model': 'poet'})
</code></pre></div>    </div>

    <p>Corresponding SQL:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> SELECT * FROM "catalogue_simple_product" WHERE
 ("catalogue_simple_product"."category_id" = 5
     AND
 "catalogue_simple_product"."attributes" @&gt; '{
     "colors": ["white", "yellow"],
     "model": "poet",
     "sizes": ["M", "L"]
 }');
</code></pre></div>    </div>

    <p>Without GIN index - 240 ms, <a href="http://explain.depesz.com/s/8Zx5">EXPLAIN ANALYSE</a>.</p>

    <p>With GIN index - 49 ms, <a href="http://explain.depesz.com/s/qYN">EXPLAIN ANALYSE</a>.</p>

    <p>Query became faster: 240 ms vs 49 ms. Result contains 3737 rows, higher selectivity than in previous request.</p>
  </li>
  <li>
    <p>Get laptops with CPU frequency 2400 and screen size 12.2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=notebook,
     attributes__contains={'speed': 2400, 'screen': 12.2})
</code></pre></div>    </div>

    <p>Corresponding SQL:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> SELECT * FROM "catalogue_simple_product" WHERE
 ("catalogue_simple_product"."category_id" = 7
     AND
 "catalogue_simple_product"."attributes" @&gt; '{"screen": 12.2, "speed": 2400}');
</code></pre></div>    </div>

    <p>Without GIN index - 222 ms, <a href="http://explain.depesz.com/s/Ocgt">EXPLAIN ANALYSE</a>.</p>

    <p>With GIN index - 34 ms, <a href="http://explain.depesz.com/s/Ik8E">EXPLAIN ANALYSE</a>.</p>

    <p>222ms vs 34ms. Result contains 10389 rows.</p>
  </li>
  <li>
    <p>Get t-shirts with red color, model polo and with size ‘M’ or ‘L’</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=tshirt,
     attributes__contains={'colors': ['red'], 'model': 'polo'},
     attributes__sizes__has_any_keys=['M', 'L'])
</code></pre></div>    </div>

    <p>Corresponding SQL:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> SELECT * FROM "catalogue_simple_product" WHERE
 ("catalogue_simple_product"."category_id" = 5
     AND
 "catalogue_simple_product"."attributes" @&gt; '{"colors": ["red"], "model": "polo"}'
     AND
 "catalogue_simple_product"."attributes" -&gt; 'sizes' ?| ARRAY['M', 'L']);
</code></pre></div>    </div>

    <p>Without GIN index - 253 ms, <a href="http://explain.depesz.com/s/6SJ">EXPLAIN ANALYSE</a>.</p>

    <p>With GIN index - 78 ms, <a href="http://explain.depesz.com/s/Lgb">EXPLAIN ANALYSE</a>.</p>

    <p>253 ms vs 78 ms. Result contains 18428 rows. In this query <code class="language-plaintext highlighter-rouge">has_any_keys</code> <em>can’t</em> use index, as we declared <em>jsonb_path_ops</em> index. But index <em>jsonb_ops</em> also will not work, because we are looking for array elements and not for first level keys.
 If such query is common and it has high selectivity, we can create index on particular JSON key:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> CREATE INDEX gin_sizes ON catalogue_simple_product USING gin ((attributes -&gt; 'sizes'));
</code></pre></div>    </div>

    <p>But in current example this don’t make sense, as filter <code class="language-plaintext highlighter-rouge">"attributes" -&gt; 'sizes' ?| ARRAY['M', 'L']</code> has low selectivity:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=tshirt,
     attributes__contains={'colors': ['red'], 'model': 'polo'},
     attributes__sizes__has_any_keys=['M', 'L']).count()
 18428

 &gt;&gt;&gt; Product.objects.filter(category=tshirt,
     attributes__contains={'colors': ['red'], 'model': 'polo'}).count()
 25162
</code></pre></div>    </div>

    <p>Only ~25% of objects are filtered by sizes in this query.</p>
  </li>
  <li>
    <p>Get laptops with CPU greater that 2000 and screen larger that 13</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=notebook, attributes__speed__gt=2000,
     attributes__screen__gt=13)
</code></pre></div>    </div>

    <p>Corresponding SQL:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> SELECT * FROM "catalogue_simple_product" WHERE
 ("catalogue_simple_product"."category_id" = 7
     AND
 "catalogue_simple_product"."attributes" -&gt; 'screen' &gt; '13'
     AND
 "catalogue_simple_product"."attributes" -&gt; 'speed' &gt; '2000')
</code></pre></div>    </div>

    <p>GIN index will not help here. If such request is common, we can create btree index on needed JSON keys:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> CREATE INDEX attrs_screen_speed ON catalogue_simple_product ((attributes -&gt; 'screen'), (attributes -&gt; 'speed'));
</code></pre></div>    </div>

    <p>Result contains 10536 rows.</p>

    <p>Without btree index query time is 352 ms, <a href="http://explain.depesz.com/s/GWNM">EXPLAIN ANALYSE</a>.</p>

    <p>With btree index - 46 ms, <a href="http://explain.depesz.com/s/YQO">EXPLAIN ANALYSE</a>.</p>
  </li>
  <li>
    <p>Get laptops with CPU frequency equal to 2200 or 2400</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=notebook, attributes__speed__in=(2200, 2400))
</code></pre></div>    </div>

    <p>Corresponding SQL:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> SELECT * FROM "catalogue_simple_product" WHERE
 ("catalogue_simple_product"."category_id" = 7
     AND
 "catalogue_simple_product"."attributes" -&gt; 'speed' IN ('2200', '2400'))
</code></pre></div>    </div>

    <p>This query is <strong>not</strong> covered by GIN index. Query time ~ 389 ms, <a href="http://explain.depesz.com/s/6U9">EXPLAIN ANALYSE</a>.</p>

    <p>Let’s try to rewrite this query to use existing GIN index</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; from django.db.models import Q
 &gt;&gt;&gt; Product.objects.filter(category=notebook).filter(Q(attributes__contains={'speed': 2200}) | Q(attributes__contains={'speed': 2400}))
</code></pre></div>    </div>

    <p>SQL:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> SELECT * FROM "catalogue_simple_product" WHERE
 ("catalogue_simple_product"."category_id" = 7
     AND
 ("catalogue_simple_product"."attributes" @&gt; '{"speed": 2200}'
         OR 
 "catalogue_simple_product"."attributes" @&gt; '{"speed": 2400}'));
</code></pre></div>    </div>

    <p>Now GIN index can be used, query time ~ 337 ms <a href="http://explain.depesz.com/s/Sdq">EXPLAIN ANALYSE</a>.</p>

    <p>As we see, there is no much difference. But let’s check the selectivity of this query.
 Result contains 124 995 rows from 250 000 possible for current category, we have very low selectivity.</p>

    <p>Create 100 laptops with CPU frequency 3200 and 100 laptops with 3500. There are no other laptops with such frequencies in database.</p>

    <p>No check the performance:</p>

    <p>Query doesn’t use GIN index:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=notebook, attributes__speed__in=(3200, 3500))
</code></pre></div>    </div>

    <p>we get the same time ~ 391 ms <a href="http://explain.depesz.com/s/ThI">EXPLAIN ANALYSE</a>.</p>

    <p>Query does use GIN index:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt;&gt;&gt; Product.objects.filter(category=notebook).filter(Q(attributes__contains={'speed': 3200}) | Q(attributes__contains={'speed': 3500}))
</code></pre></div>    </div>

    <p>Now we have query time only 0.773 ms! <a href="http://explain.depesz.com/s/rqXN">EXPLAIN ANALYSE</a>.</p>
  </li>
</ol>

<h4 id="resume-of-indexes">Resume of indexes</h4>

<p>We can use single GIN index (jsonb_path_ops) to query by several attributes, and not just by one!</p>

<p>Of course, it is not a silver bullet. We must always take into account, what data is we working with. And consequently choose right design.</p>

<h3 id="nosql-database-mongodb">NoSQL database (MongoDB)</h3>

<p>Can we store same data and make similar queries in MongoDB (v3.0.6)?</p>

<p>To use only one single index in queries by unknown fields in advance, we need to use different structure in MongoDB.</p>

<p>Field attributes will be a list of embedded documents, that have name and value:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.catalogue_simple.find().pretty()
{
    "_id" : ObjectId("560ab1970a0a88fe77d00f02"),
    "category" : "tshirts",
    "name" : "Silk tshirt",
    "price" : 100,
    "attributes" : [
        {
            "name" : "colors",
            "value" : "red"
        },
        {
            "name" : "colors",
            "value" : "black"
        },
        {
            "name" : "sizes",
            "value" : "S"
        },
        {
            "name" : "sizes",
            "value" : "M"
        },
        {
            "name" : "model",
            "value" : "polo"
        },
        {
            "name" : "material",
            "value" : "silk"
        }
    ]
}
{
    "_id" : ObjectId("560ab1dd0a0a88fe77d00f03"),
    "category" : "tshirts",
    "name" : "Bamboo tshirt",
    "price" : 120,
    "attributes" : [
        {
            "name" : "colors",
            "value" : "white"
        },
        {
            "name" : "colors",
            "value" : "yellow"
        },
        {
            "name" : "sizes",
            "value" : "M"
        },
        {
            "name" : "sizes",
            "value" : "L"
        },
        {
            "name" : "sizes",
            "value" : "XL"
        },
        {
            "name" : "model",
            "value" : "poet"
        },
        {
            "name" : "material",
            "value" : "bamboo"
        }
    ]
}
{
    "_id" : ObjectId("560ab2cb0a0a88fe77d00f04"),
    "category" : "notebook",
    "name" : "MacBook Pro",
    "price" : 2000,
    "attributes" : [
        {
            "name" : "brand",
            "value" : "Apple"
        },
        {
            "name" : "screen",
            "value" : 15
        },
        {
            "name" : "speed",
            "value" : 2200
        },
        {
            "name" : "hd",
            "value" : 256
        }
    ]
}
{
    "_id" : ObjectId("560ab2ec0a0a88fe77d00f05"),
    "category" : "notebook",
    "name" : "ATIV Book 9",
    "price" : 1200,
    "attributes" : [
        {
            "name" : "brand",
            "value" : "Samsung"
        },
        {
            "name" : "screen",
            "value" : 12.2
        },
        {
            "name" : "speed",
            "value" : 2400
        },
        {
            "name" : "hd",
            "value" : 128
        }
    ]
}
</code></pre></div></div>

<h3 id="queries-mongodb">Queries (MongoDB)</h3>

<ol>
  <li>
    <p>Get t-shirts with both ‘M’ and ‘L’ sizes:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; db.catalogue_simple.find({attributes: {$all: [
     {"$elemMatch": {"name": "sizes", "value": "M"}},
     {"$elemMatch": {"name": "sizes", "value": "L"}}
 ]}, category: 'tshirts'})

 {"name" : "Bamboo tshirt", /* ... */}
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get t-shirts with both ‘M’ and ‘L’ sizes, both white and yellow colors, with poetry on it (model=poet):</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; db.catalogue_simple.find({attributes: {$all: [
     {"$elemMatch": {"name": "sizes", "value": "M"}},
     {"$elemMatch": {"name": "sizes", "value": "L"}},
     {"$elemMatch": {"name": "colors", "value": "white"}},
     {"$elemMatch": {"name": "colors", "value": "yellow"}},
     {"$elemMatch": {"name": "model", "value": "poet"}}
 ]}, category: 'tshirts'})

 {"name" : "Bamboo tshirt", /* ... */}
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get laptops with CPU frequency 2400 and screen size 12.2</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; db.catalogue_simple.find({attributes: {$all: [
     {"$elemMatch": {"name": "speed", "value": 2400}},
     {"$elemMatch": {"name": "screen", "value": 12.2}}
 ]}, category: 'notebook'})

 {"name" : "ATIV Book 9", /* ... */}
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get t-shirts with red color, model polo and with size ‘M’ or ‘L’</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; db.catalogue_simple.find({attributes: {$all: [
     {"$elemMatch": {"name": "colors", "value": "red"}},
     {"$elemMatch": {"name": "model", "value": "polo"}},
     {"$elemMatch": {"name": "sizes", "value": {"$in": ["M", "L"]}}}
 ]}, category: 'tshirts'})

 {"name" : "Silk tshirt", /* ... */}
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get laptops with CPU greater that 2000 and screen larger that 13</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; db.catalogue_simple.find({attributes: {$all: [
     {"$elemMatch": {"name": "speed", "value": {"$gt": 2000}}},
     {"$elemMatch": {"name": "screen", "value": {"$gt": 13}}}
 ]}, category: 'notebook'})

 {"name" : "MacBook Pro", /* ... */}
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get laptops with CPU frequency equal to 2200 or 2400</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; db.catalogue_simple.find({attributes: {$all: [
     {"$elemMatch": {"name": "speed", "value": {"$in": [2200, 2400]}}},
 ]}, category: 'notebook'})

 {"name" : "MacBook Pro", /* ... */}, {"name" : "ATIV Book 9", /* ... */}
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="indexes-mongodb">Indexes (MongoDB)</h3>

<p>We can create <a href="http://docs.mongodb.org/manual/core/index-multikey/#index-arrays-with-embedded-documents">multikey index</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.catalogue_simple.ensureIndex({"attributes.name" : 1, "attributes.value" : 1})
</code></pre></div></div>

<p>For fairness, create index on category (django automatically creates it for ForeignKey fields)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.catalogue_simple.ensureIndex({"category": 1})
</code></pre></div></div>

<p>Keep in mind, that MongoDB will use index only for first filter from $all operator. Although MongoDB docs tells about <a href="http://docs.mongodb.org/manual/core/index-intersection/">index intersection</a>, looks like it can’t be used in our case.</p>

<p>Illustrative example. Imagine, that in database there is only 1 product with size “XXXS” and a lot of products with size “M”.</p>

<p>We want products, that have both sizes “XXXS” and “M”.</p>

<p>Check out the query:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.catalogue_simple.find({attributes: {$all: [
    {"$elemMatch": {"name": "sizes", "value": "M"}},
    {"$elemMatch": {"name": "sizes", "value": "XXXS"}},
]}, category: 'tshirts'})
</code></pre></div></div>

<p>MongoDB will apply index only to “M” value. As a result, many documents will be scanned:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"nReturned" : 1,
"executionTimeMillis" : 1902,
"totalKeysExamined" : 249934,
"totalDocsExamined" : 249934,
</code></pre></div></div>

<p>But if we place size “XXXS” to the first position:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.catalogue_simple.find({attributes: {$all: [
    {"$elemMatch": {"name": "sizes", "value": "XXXS"}},
    {"$elemMatch": {"name": "sizes", "value": "M"}},
]}, category: 'tshirts'})
</code></pre></div></div>

<p>only one document will be scanned:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"nReturned" : 1,
"executionTimeMillis" : 0,
"totalKeysExamined" : 1,
"totalDocsExamined" : 1,
</code></pre></div></div>

<p>The moral is, put filter with highest selectivity to the first place. Unfortunately, we don’t always have such information.</p>

<h4 id="test-data-mongodb">Test data (MongoDB)</h4>

<p>Test data is exactly the same as in PostgreSQL (only structure is different): 4 categories, 250 000 products in each category, 1 000 000 in total.</p>

<h4 id="queries-and-indexes-mongodb">Queries and indexes (MongoDB)</h4>

<ol>
  <li>
    <p>Get t-shirts with both ‘M’ and ‘L’ sizes:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; db.catalogue_simple.find({attributes: {$all: [
     {"$elemMatch": {"name": "sizes", "value": "M"}},
     {"$elemMatch": {"name": "sizes", "value": "L"}}
 ]}, category: 'tshirts'})
</code></pre></div>    </div>

    <p>Without multikey index on attributes query time is 706 ms, category index is used.</p>

    <p>Output of <code class="language-plaintext highlighter-rouge">.explain('executionStats')</code>:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> "winningPlan" : {
     // ...
     "indexName" : "category_1",
 }
 "executionStats" : {
     "nReturned" : 66412,
     "executionTimeMillis" : 706,
     "totalKeysExamined" : 250001,
     "totalDocsExamined" : 250001,
 }
</code></pre></div>    </div>

    <p>After creation of multikey index on attributes field nothing changes, as MongoDB optimizer decides, that category index is better (i suppose because of low selectivity of attributes query).</p>
  </li>
  <li>
    <p>Get t-shirts with both ‘M’ and ‘L’ sizes, both white and yellow colors, with poetry on it (model=poet):</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; db.catalogue_simple.find({attributes: {$all: [
     {"$elemMatch": {"name": "sizes", "value": "M"}},
     {"$elemMatch": {"name": "sizes", "value": "L"}},
     {"$elemMatch": {"name": "colors", "value": "white"}},
     {"$elemMatch": {"name": "colors", "value": "yellow"}},
     {"$elemMatch": {"name": "model", "value": "poet"}},
 ]}, category: 'tshirts'})
</code></pre></div>    </div>

    <p>Behaviour is similar to first query.</p>

    <p>Behaviour can change, if we put higher selective filter to the first place. In test data color is more selective, that size. So, make it first:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; db.catalogue_simple.find({attributes: {$all: [
         {"$elemMatch": {"name": "colors", "value": "white"}},
         {"$elemMatch": {"name": "sizes", "value": "M"}},
         {"$elemMatch": {"name": "sizes", "value": "L"}},
         {"$elemMatch": {"name": "colors", "value": "yellow"}},
         {"$elemMatch": {"name": "model", "value": "poet"}},
     ]}, category: 'tshirts'}).explain('executionStats')
</code></pre></div>    </div>

    <p>Explain:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> "winningPlan" : {
     // ...
     "indexName" : "attributes.name_1_attributes.value_1",
 }
 "executionStats" : {
     "nReturned" : 3737,
     "executionTimeMillis" : 658,
     "totalKeysExamined" : 124902,
     "totalDocsExamined" : 124902,
 }
</code></pre></div>    </div>

    <p>Query time - 658 ms.</p>
  </li>
  <li>
    <p>Get laptops with CPU frequency 2400 and screen size 12.2</p>

    <p>Same as points 1 and 2.</p>
  </li>
  <li>
    <p>Get t-shirts with red color, model polo and with size ‘M’ or ‘L’</p>

    <p>Same as points 1 and 2.</p>
  </li>
  <li>
    <p>Get laptops with CPU greater that 2000 and screen larger that 13</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &gt; db.catalogue_simple.find({attributes: {$all: [
     {"$elemMatch": {"name": "speed", "value": {"$gt": 2000}}},
     {"$elemMatch": {"name": "screen", "value": {"$gt": 13}}}
 ]}, category: 'notebook'}).explain('executionStats')
</code></pre></div>    </div>

    <p>Remember, PostgreSQL can’t use GIN index in such a query.
 But multikey index in current data structure can work.</p>

    <p>We have good selectivity for speed in this request:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> "winningPlan" : {
     // ...
     "indexName" : "attributes.name_1_attributes.value_1",
 }
 "executionStats" : {
     "nReturned" : 10536,
     "executionTimeMillis" : 160,
     "totalKeysExamined" : 62472,
     "totalDocsExamined" : 62472,
 }
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get laptops with CPU frequency equal to 2200 or 2400</p>

    <p>Same as previous points.</p>
  </li>
</ol>

<h3 id="resume">Resume</h3>

<p>PostgreSQL 9.4 introduced new type jsonb. It can be used effectively in queries. And we can use single index to query on different json keys. Not all operations are available (for example greater than/less than, we need a separate index on particular key), but anyway this is incredibly useful for a wide range of tasks. And starting from Django 1.9 this functionality is available out of the box.</p>

<p>MongoDB doesn’t have analogue to <code class="language-plaintext highlighter-rouge">@&gt;</code> operator. We can adopt the structure of data to make similar queries, using one index. But it is less effective, than in PostgreSQL. Because index is applied only to one key. On the other hand MongoDB support higher range of operations when filtering on <em>any</em> <em>one</em> key, using single index.</p>

<p>I really like JSON in PostgreSQL, it can be used in many tasks. And we have all advantages of SQL: joins and transactions, that are not presented in MongoDB. And now it is supported by Django ORM.</p>

<h3 id="useful-links">Useful links</h3>

<ul>
  <li><a href="https://docs.djangoproject.com/en/dev/ref/contrib/postgres/fields/#jsonfield">Django JSONField docs</a></li>
  <li><a href="http://www.postgresql.org/docs/9.4/static/datatype-json.html">PostgreSQL JSON type docs</a></li>
  <li><a href="http://www.postgresql.org/docs/9.4/static/functions-json.html">PostgreSQL JSON functions and operations docs</a></li>
  <li><a href="http://www.youtube.com/watch?v=78A2gJBgL9g">Christophe Pettus - PostgreSQL Proficiency for Python People - PyCon 2015 (video)</a></li>
  <li><a href="http://thebuild.com/presentations/json2015-pgconfus.pdf">PostgreSQL and JSON: 2015. Christophe Pettus. PGConf US 2015 (slides)</a></li>
  <li><a href="https://events.yandex.ru/lib/talks/1707/">Asya Kamsky, Yandex 2014 MongoDB meetup</a></li>
</ul>

  </div>

  <div class="post-categories">

  <span><a href="/en/category/database/index.html">database</a></span>
&nbsp;

  <span><a href="/en/category/django/index.html">django</a></span>
&nbsp;

  <span><a href="/en/category/mongodb/index.html">mongodb</a></span>
&nbsp;

  <span><a href="/en/category/postgresql/index.html">postgresql</a></span>
&nbsp;

  <span><a href="/en/category/sql/index.html">sql</a></span>


</div><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://st4lk.github.io/en/blog/2015/09/30/trying-json-combo-django-and-postgresql.html';
      this.page.identifier = 'https://st4lk.github.io/blog/2015/09/30/trying-json-combo-django-and-postgresql.html';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://lexev-dev.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/en/blog/2015/09/30/trying-json-combo-django-and-postgresql.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/en/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name"></li><li><a class="u-email" href="mailto:alexevseev@gmail.com">alexevseev@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"></div>

    </div>

  </div>

</footer>
<script id="dsq-count-scr" src="//lexev-dev.disqus.com/count.js" async></script></body>

</html>
