<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="https://st4lk.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://st4lk.github.io/" rel="alternate" type="text/html" hreflang="ru" /><updated>2023-10-23T21:11:52+00:00</updated><id>https://st4lk.github.io/feed.xml</id><title type="html">Alexey Evseev</title><subtitle></subtitle><author><name>Alexey Evseev</name></author><entry><title type="html">Sublime Text и Language Server Protocol</title><link href="https://st4lk.github.io/blog/2019/02/19/sublime-text-and-language-server-protocol-lsp.html" rel="alternate" type="text/html" title="Sublime Text и Language Server Protocol" /><published>2019-02-19T18:19:43+00:00</published><updated>2019-02-19T18:19:43+00:00</updated><id>https://st4lk.github.io/blog/2019/02/19/sublime-text-and-language-server-protocol-lsp</id><author><name>Alexey Evseev</name></author><category term="python" /><category term="sublime" /><category term="lsp" /><summary type="html">Language Server Protocol (LSP) Language Server Protocol (LSP) - протокол для общения между IDE и языковым сервером. Сервер предоставляет такие функции, как автокомплит, переход к функции (goto) и прочее. Т.е. когда IDE нужно показать автокомплит на языке, скажем, python - происходит запрос к специальному серверу. В ответе возвращаются необходимые данные, которые IDE уже может отобразить. Радует то, что это инициатива крупной компании - Microsoft.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://i.ibb.co/4K4zp06/sublime-256-lsp-light.png" /><media:content medium="image" url="https://i.ibb.co/4K4zp06/sublime-256-lsp-light.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Ловушка при подсчете связанных объектов в Django</title><link href="https://st4lk.github.io/blog/2017/01/14/count-filtered-related-objects-django.html" rel="alternate" type="text/html" title="Ловушка при подсчете связанных объектов в Django" /><published>2017-01-14T18:19:43+00:00</published><updated>2017-01-14T18:19:43+00:00</updated><id>https://st4lk.github.io/blog/2017/01/14/count-filtered-related-objects-django</id><author><name>Alexey Evseev</name></author><category term="database" /><category term="django" /><category term="sql" /><summary type="html">Задача: для каждого объекта подсчитать количество связанных объектов, удовлетворяющих определенному условию.</summary></entry><entry><title type="html">Django: сигнал или метод модели?</title><link href="https://st4lk.github.io/blog/2016/08/01/django-signal-or-model-method.html" rel="alternate" type="text/html" title="Django: сигнал или метод модели?" /><published>2016-08-01T18:19:43+00:00</published><updated>2016-08-01T18:19:43+00:00</updated><id>https://st4lk.github.io/blog/2016/08/01/django-signal-or-model-method</id><author><name>Alexey Evseev</name></author><category term="django" /><category term="signal" /><summary type="html">Когда нужно написать какой-либо функционал, который должен быть выполнен при сохранении django модели, у меня всегда возникал вопрос - где его лучше реализовать. В сигнале или в методе save() модели? Давайте разберемся, что и в каких ситуациях более удобно.</summary></entry><entry><title type="html">Пробуем JSON в Django и PostgreSQL (и сравниваем с MongoDB)</title><link href="https://st4lk.github.io/blog/2015/09/30/trying-json-combo-django-and-postgresql.html" rel="alternate" type="text/html" title="Пробуем JSON в Django и PostgreSQL (и сравниваем с MongoDB)" /><published>2015-09-30T18:19:43+00:00</published><updated>2015-09-30T18:19:43+00:00</updated><id>https://st4lk.github.io/blog/2015/09/30/trying-json-combo-django-and-postgresql</id><author><name>Alexey Evseev</name></author><category term="database" /><category term="django" /><category term="mongodb" /><category term="postgresql" /><category term="sql" /><summary type="html">В Django 1.9 будет добавлено поле JSONField, его можно использовать с базой данных PostgreSQL &amp;gt;= 9.4. Давайте попробуем с ним поработать и оценить, насколько оно удобно.</summary></entry><entry><title type="html">OAuth и django rest framework</title><link href="https://st4lk.github.io/blog/2015/07/18/oauth-and-django-rest-framework.html" rel="alternate" type="text/html" title="OAuth и django rest framework" /><published>2015-07-18T18:19:43+00:00</published><updated>2015-07-18T18:19:43+00:00</updated><id>https://st4lk.github.io/blog/2015/07/18/oauth-and-django-rest-framework</id><author><name>Alexey Evseev</name></author><category term="api" /><category term="django" /><category term="oauth" /><summary type="html">Star Тема избитая, но мне не удалось найти готового решения, которое полностью бы меня устроило. Поэтому пишу сам :). Итак, у нас есть “одностраничный” веб сайт, который общается с бекендом посредством REST API. Клиентская часть может быть написана с помощью ember, angularjs или чего-то подобного. Бекенд - django rest framework (DRF). И есть тривиальная задача - добавить вход через социальные сети (OAuth протокол).</summary></entry><entry><title type="html">Tornado and pgettext</title><link href="https://st4lk.github.io/blog/2015/06/05/tornado-and-pgettext.html" rel="alternate" type="text/html" title="Tornado and pgettext" /><published>2015-06-05T18:19:43+00:00</published><updated>2015-06-05T18:19:43+00:00</updated><id>https://st4lk.github.io/blog/2015/06/05/tornado-and-pgettext</id><author><name>Alexey Evseev</name></author><category term="i18n" /><category term="tornado" /><summary type="html">Недавно (26 мая 2015 года) вышел релиз tornado 4.2. В него вошли разные дополнения, пожалуй основные из них - модули tornado.locks и tornado.queues. Они перекочевали из пакета Toro, подробное описание процесса от Jesse Jiryu Davis в его блоге. Здесь же хочу рассказать о другой маленькой функции, которая была добавлена с моей помощью - pgettext.</summary></entry><entry><title type="html">OAuth step by step</title><link href="https://st4lk.github.io/blog/2015/05/16/oauth-step-step.html" rel="alternate" type="text/html" title="OAuth step by step" /><published>2015-05-16T18:19:43+00:00</published><updated>2015-05-16T18:19:43+00:00</updated><id>https://st4lk.github.io/blog/2015/05/16/oauth-step-step</id><author><name>Alexey Evseev</name></author><category term="api" /><category term="oauth" /><category term="security" /><summary type="html">Gist OAuth протокол бывает двух версий: 1.0 и 2.0. Большинство сервисов сегодня используют версию 2.0, вероятно потому что ее проще реализовать. Так же версию 2.0 можно относительно безопасно использовать в standalone-приложениях (те, которые без сервера). Для понимания протоколов очень полезно взглянуть на их реализацию. Тут я приведу несколько скриптов, которые общаются с OAuth-провайдерами разных версий. Т.е. все скрипты реализуют функционал клиента (не сервера). Используются только стандартные python библиотеки. Вот почему глядя на них лучше понимаешь сам протокол OAuth - все перед глазами и все более-менее знакомое. Конечно, для реальной работы нужно использовать только готовые и проверенные временем пакеты. Эти скрипты только для понимания процесса. Разбираться с готовыми библиотеками порой бывает сложно, они разбиты на много модулей, могут использоваться разные сторонние пакеты, и в итоге общая картина ускользает из виду.</summary></entry><entry><title type="html">Python tips &amp;amp; tricks</title><link href="https://st4lk.github.io/blog/2015/04/30/base-python-tips-tricks.html" rel="alternate" type="text/html" title="Python tips &amp;amp; tricks" /><published>2015-04-30T18:19:43+00:00</published><updated>2015-04-30T18:19:43+00:00</updated><id>https://st4lk.github.io/blog/2015/04/30/base-python-tips-tricks</id><author><name>Alexey Evseev</name></author><category term="python" /><summary type="html">Недавно прочитал книгу Марка Лутца “Learning Python”, 5-ое издание. Привожу список самых интересных фишек (по моему мнению) оттуда, что-то вроде конспекта.</summary></entry><entry><title type="html">Слушаем wifi с помощью wireshark</title><link href="https://st4lk.github.io/blog/2015/04/17/listen-wifi-with-wireshark.html" rel="alternate" type="text/html" title="Слушаем wifi с помощью wireshark" /><published>2015-04-17T18:19:43+00:00</published><updated>2015-04-17T18:19:43+00:00</updated><id>https://st4lk.github.io/blog/2015/04/17/listen-wifi-with-wireshark</id><author><name>Alexey Evseev</name></author><category term="fun" /><category term="security" /><summary type="html">Всегда знал, что можно посмотреть сетевые пакеты, которые передаются по wifi сети. Но на практике этого не делал (на работе анализировал сетевые пакеты, но то был не HTTP протокол). Решил восполнить этот пробел, ведь это интересно и полезно. Более стройно выстраивается понимание протоколов TCP-IP и HTTP. Видно, как летят наши пароли и сессии, после такого опыта поневоле начинаешь относиться к безопасности сайта с большим трепетом.</summary></entry><entry><title type="html">Отладка SQL в django тестах</title><link href="https://st4lk.github.io/blog/2015/03/04/debug-sql-django-test.html" rel="alternate" type="text/html" title="Отладка SQL в django тестах" /><published>2015-03-04T18:19:43+00:00</published><updated>2015-03-04T18:19:43+00:00</updated><id>https://st4lk.github.io/blog/2015/03/04/debug-sql-django-test</id><author><name>Alexey Evseev</name></author><category term="database" /><category term="django" /><category term="logging" /><category term="sql" /><summary type="html">В django тестах можно замерять количество сделанных SQL запросов: def test_home(self): with self.assertNumQueries(1): response = self.client.get(&apos;/&apos;) self.assertEqual(response.status_code, 200) Если код в контексте assertNumQueries сделает иное количество обращений к БД, чем ожидается (здесь 1), то тест выдает ошибку. Но когда такой тест не проходит, бывает трудно определить лишний отправленный запрос. Для отладки такого случая удобно вывести в консоль отправленные SQL запросы. Далее опишу, как этого добиться.</summary></entry></feed>