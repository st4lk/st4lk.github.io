---
layout: post
title:  "OAuth step by step"
date:   2015-05-16 18:19:43 +0000
categories: api oauth security
redirect_from:
  - /2015/oauth-step-step/
  - /blog/2015/05/16/oauth-step-step.html
---

<div class="gist-wrp"><div class="github-btn" id="github-btn" style="float:right;"> <a class="gh-btn" id="gh-btn" href="https://gist.github.com/st4lk/4b71b72007a666435f81" target="_blank"> <span class="gh-ico"></span> <span class="gh-text" id="gh-text">Gist</span> </a></div></div>

[![OAuth step by step](https://img-fotki.yandex.ru/get/9819/85893628.c68/0_185253_82b5fefa_M.png "OAuth step by step")]({{ site.baseurl }}{{ page.url }})

OAuth протокол бывает двух версий: 1.0 и 2.0.

Большинство сервисов сегодня используют версию 2.0, вероятно потому что
ее проще реализовать. Так же версию 2.0 можно относительно безопасно использовать в
standalone-приложениях (те, которые без сервера).

Для понимания протоколов очень полезно взглянуть на их реализацию.
Тут я приведу несколько скриптов, которые общаются с OAuth-провайдерами разных версий.
Т.е. все скрипты реализуют функционал клиента (не сервера).
Используются только стандартные python библиотеки.
Вот почему глядя на них лучше понимаешь сам протокол OAuth - все перед глазами и все более-менее знакомое.
Конечно, для реальной работы нужно использовать только готовые и проверенные временем пакеты.
Эти скрипты только для понимания процесса. Разбираться с готовыми библиотеками порой бывает сложно, они разбиты на много модулей, могут использоваться разные сторонние пакеты, и в итоге общая картина ускользает из виду.

<!--more-->

Для начала немного теории.
Наверняка вы знаете, что есть два понятия - _аутентификация_ (authentication) и _авторизация_ (authorization).
Они вроде бы об одном и том же, но все-таки немного о разном.
На всякий случай напомню:

- аутентификация - это процесс подтверждения подлинности.
    Т.е. нам нужно просто узнать, что данный человек действительно владеет аккаунтом google с таким id и нам этого достаточно.
    Просто залогинить пользователя, не получая никаких прав на какие-либо действия с аккаунтом google'а.
    Этим занимается например протокол OpenID (хотя сейчас google предлагает [другой способ](https://developers.google.com/identity/sign-in/auth-migration#sign-in), OpenID - [deprecated](https://developers.google.com/identity/protocols/OpenID2)).
- авторизация - процесс предоставления полномочий что-то делать с аккаунтом.
    Авторизация уже включает в себя аутентификацию, но дает дополнительные возможности.
    Например, не просто подтвердить, что пользователь действительно является владельцем аккаунта с определенным id, но еще и узнать его email. А возможно и написать что-то на его стене.
    Вот это предоставляет протокол OAuth.

Чтобы легче запомнить я использую слово "автор". Если есть "автор" - значит речь идет о правах (авторстве). Если нет - значит просто проверка подлинности.

### OAuth 1.0

Спецификация: [http://tools.ietf.org/html/rfc5849](http://tools.ietf.org/html/rfc5849)

Самое главное, что нужно запомнить - в OAuth 1.0 **все** запросы подписываются секретным ключом.
Секретный ключ нужно хранить только в безопасном месте, единственное такое место - это сервер.
Благодаря этому протокол обеспечивает полную безопасность, даже если не используется https.
Безопасность в том плане, что даже подслушав запрос злоумышленник не сможет сделать другой валидный запрос.
Подслушать сами передаваемые данные он конечно сможет, чтобы их скрыть нужен https.

<script src="https://gist.github.com/st4lk/314e181faaea7d671d0e.js"></script>

### OAuth 1.0 less-legged (2-legged, 1-legged, 0-legged)

Это модификация протокола OAuth 1.0, в котором пользователь никак не зайдествован.
Формально это уже не OAuth протокол, т.к. в спецификции такая последовательность не описана.
Просто используются те же приемы, поэтому и называют так же.
В этом случае клиентское приложение является пользователем, оно может запрашивать либо общедоступные ресурсы, либо ресурсы, доступные самому клиентскому приложению (даже приватные).

<script src="https://gist.github.com/st4lk/719729c03cf0314179b4.js"></script>

### OAuth 2.0 с участием сервера

Спецификация: [http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749)

Интересно, что в заглавии спецификации OAuth 2.0 назван фреймворком.
В то время как в заглавии [спецификации](http://tools.ietf.org/html/rfc5849) OAuth 1.0 назван протоколом.

Для обеспечения полной безопасности OAuth 2.0 необходимо отправлять запросы по https (https должен обеспечивать service provider, например facebook).
Получив access_token уже не нужно подписывать запросы секретным ключом.
Т.е. если кто-то подслушает запрос и увидит access_token, то он сможет сделать валидный запрос. Вот зачем нужен https.
Кроме того при получении access_token, секрет передается по http в открытом виде.

У полученного access_token всегда есть ограниченное время жизни.

В связи с этими особенностями (и некоторыми другими), один из проектировщиков протокола OAuth 1.0 даже отказался от участия в разработке OAuth 2.0, ведь последний очень легко реализовать неправильно и в результате безопасность не будет гарантирована. Подробности можно почитать по [ссылке](https://gist.github.com/nckroy/dd2d4dfc86f7d13045ad715377b6a48f).

Последовательность шагов для получения access_token по OAuth 2.0, которая включает сервер.
Сервер для получения access_token отправляет секретный код. Обратите внимание, не используется ни одна крипто-библиотека.

<script src="https://gist.github.com/st4lk/4b71b72007a666435f81.js"></script>

### OAuth 2.0 без участия сервера

С OAuth 2.0 можно работать и без сервера по упрощенной схеме. В этом случае мы тоже получаем access_token, но для его получения не нужно знать секрет приложения! Обычно время жизни у access_token, полученного таким способом, маленькое (1-2 часа), в то время как время жизни, полученного с участием сервера больше (может быть несколько десятков дней).

<script src="https://gist.github.com/st4lk/af1db97e36897b918f22.js"></script>
